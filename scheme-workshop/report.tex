\documentclass[dvipsnames,sigplan,screen,review,anonymous,acmthm,nonacm]{acmart}
% \documentclass[dvipsnames,sigplan,screen,acmthm]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{none}
% \setcopyright{acmcopyright}
% \copyrightyear{2018}
% \acmYear{2018}
% \acmDOI{10.1145/1122445.1122456}

%% TODO: does this matter?

% \citestyle{acmauthoryear}
\citestyle{acmnumeric}

\input{preamble}
\input{defs}

\begin{document}

\title{miniDusa: An Extensible Finite-Choice Logic Programming Language (Lightning Talk)}


%% TODO: alphabetical by last name or by first
%% name?? not sure which or it it matters

\author{Ari Prakash}
% \orcid{XXXX-XXXX-XXXX-XXXX}
\affiliation{%
  \institution{Northeastern University}
  \city{Boston}
  \state{MA}
  \country{USA}
}
\email{prakash.ar@northeastern.edu}
\authornote{Both authors contributed equally to this work}


\author{Zachary Eisbach}
% \orcid{0009-0005-3028-7211}
\affiliation{%
  \institution{Northeastern University}
  \city{Boston}
  \state{MA}
  \country{USA}
}
\email{eisbach.z@northeastern.edu}
\authornotemark[1]

% \authorsaddresses{}

\maketitle

\section{Introduction}

\Dusa{}~\cite{martens2025dusa} % maybe cite dusa.rocks impl too?
is a recently designed logic programming language featuring
\emph{mutually exclusive choice} as a primitive to enable
computation of solutions that satisfy constraints.

% TODO: sentence to bridge this gap?

We introduce \miniDusa{}, a \Dusa{}-inspired
% TODO: (nit) italics are awkward here. maybe omit DSL? 
\emph{hosted domain-specific language} (DSL) implemented using Racket and
the \syntaxspec{} metalanguage~\cite{ballantyne2024pearl}. % cite docs?
This architecture lets our implementation inherit tooling and features
from the host, like macro-extensibility, essentially ``for free''.


\section{miniDusa by Example}

A finite-choice logic program describes \emph{solutions}
(i.e. sets of consistent facts), which are obtained using a \emph{solver}.
To illuminate the semantics of \miniDusa{}, we walk through
a program whose solutions are the 3-colorings of some graph:

\begin{verbatim}
(logic
  (edge 'a 'b) (edge 'a 'c)  ; ... more ...
  ((edge X Y) :- (edge Y X))
  ((node X) :- (edge X _))
\end{verbatim}
A finite-choice logic program consists of \emph{facts} and \emph{rules}.
% like Datalog programs. 
The fact \texttt{(edge 'a 'b)} represents an edge from \texttt{'a} to \texttt{'b}.
The premise of the rule \texttt{((edge X Y) :- (edge Y X))} will be
instantiated with this fact to conclude \texttt{(edge 'b 'a)}.
These facts and rules thus encode an undirected graph.

\begin{verbatim}
  (((color X) is {'r 'g 'b}) :- (node X))
\end{verbatim}
% TODO: (nit) should this be indented?
The conclusion of this rule is a \emph{functional proposition}
(indicated with \texttt{is}), as opposed to the \emph{relational} propositions above.
Each functional proposition has a unique associated value---for instance,
the value associated to \texttt{color 'a} will be a
\emph{choice} among \texttt{'r}, \texttt{'g}, and \texttt{'b}.

Without any added constraints, the solutions will simply enumerate all
possible assignments of colors to nodes. We forbid solutions from
assigning the same color to adjacent nodes as follows to complete the \miniDusa{} program:

\begin{verbatim}
  (forbid (edge X Y)
          ((color X) is C)
          ((color Y) is C))
\end{verbatim}
  % ((ok) is {#t})
  % (((ok) is {#f}) :- (edge X Y)
  %                    ((color X) is C)
  %                    ((color Y) is C)))
% The (functional) fact \texttt{((ok) is {\#t})} will always hold.
% If adjacent nodes have the same color, then \texttt{((ok) is {\#f})}
% will be concluded; this would violate the uniqueness requirement noted
% above, causing any such solutions to be rejected. 

We implement a relatively na√Øve solver based on the ``fact-set semantics''
described in~\cite{martens2025dusa}. Solving produces a stream of solutions,
each of which may be queried by users.

\section{Extensibility via Macros}

We may write \emph{macros} abstracting over the common patterns seen in the
previous example.
% The previous example is representative of common patterns that arise in logic
% programming contexts, and we would prefer to see abstractions over them. 
Dusa
provides \texttt{\#forbid} as syntactic sugar over the \texttt{ok} fact and rule
shown earlier. miniDusa allows for this through user-defineable macros that
expand into miniDusa core syntax. This also allows users to express constructs
in their problem domain in a more natural way. Consider the
\texttt{(edge 'a 'b)} facts from earlier, we can express them in more familiar
adjacency-list notation.
The previous example could be rewritten using macros as:

Such macros can ease the language implementation process as well;

The \texttt{ok} pattern from the example is 

conveniently implemented as a
macro and provided by \miniDusa{} as 

In fact, forbid and other constraints are conveniently implemented as macros

\begin{verbatim}
(define-dsl-syntax undirected-graph ...)
(define-dsl-syntax forbid ...)
(logic
  (undirected-graph edge node
    ('a ['b 'c])  #| ... more ... |# )
  (((color X) is {'r 'g 'b}) :- (node X))
  (forbid (edge X Y)
          ((color X) is C)
          ((color Y) is C)))
\end{verbatim}

Macros are allowed to expand into a collection of facts and rules. The
\texttt{syntax-spec} metalangauge gives us the ability to define macros
expanding to the core syntax, and to run static validation of the fully-expanded
code at compile time. 

% something like the example above is made possible through
% syntax-spec blah blah

% TODO: not sure why this isn't properly centering...
\begin{center}
  \begin{tikzpicture}[
    box/.style={
      rectangle, draw, align=center,
      minimum width=2.2cm, minimum height=1.1cm,
      },
      label/.style={ midway, font=\small },
      every path/.style={-Stealth, thick}
    ]
    \node[box] (a) at (-2, 2) {\miniDusa{} +\\ extensions};
    \node[box] (b) at ( 2, 2) {Core\\ \miniDusa{}};
    \node[box] (c) at ( 2, 0) {Racket\\with runtime};
    \node[box, shape=ellipse] (d) at (-2, 0) {Solutions};
    
    % janky but it might work
    \draw[loop right] (b) to (b) node[font=\small, right, xshift=1.4cm, yshift=-0.7cm] {Check};
    
    \draw (a) -- (b) node[label, above] {Expand};
    \draw (b) -- (c) node[label, left] {Compile};
    \draw (c) -- (d) node[label, below] {Solve};
  \end{tikzpicture}
\end{center}

\section{Interoperability}

Using \texttt{syntax-spec}, we not only inherit Racket's macro system, we can
also have richer interoperability with Racket itself. miniDusa allows the user
to \emph{import} arbitrary Racket functions to be used as functional relations
within miniDusa. Since running arbitrary functions backwards is impossible, we
only allow this when all arguments are known, and we want to either bind or
verify the return value.

% KEEP IN MIND: this is the part that should be interesting for everyone!
% even if they don't care about logic programs. phrase with that in mind

% probably say a little bit about syntax-spec
% insert: the diagram
% do it in this order because it justifies macros?

% TODO: do we want to switch the order of these two subsections?

% the previous example is indicative of many miniDusa programs
% we want to abstract over common behavior, like the ok stuff
% dusa provides this as #forbid
% we conveniently implement it as a macro
% this is an instance of syntax-spec + DSL making impl easier :)

% users may also want a reusable graph definition, and ideally
% one that is less verbose. we again can do this with a macro!
% this is more powerful than before: we expect _users_ to write
% such macros, not just us as language implementers

% insert: the fully rewritten version.
% probably not any macro definitions, maybe just with ...

% reiterate that due to how syntax-spec is set-up, we get
% nice expansion into core miniDusa to do some checks before
% going any farther. i think that pattern is hard without syntax-spec
% META: see this is why i was unsure about the order of these subsections

% syntax spec not only lets us get macros, but also host language interop
% insert: the code with the contrived example
% then, talk about how we can use arbitrary racket functions,
% which is also nice for users: we inherit expressivity and can use libraries/etc

% \section{Conclusion}
% TODO: depending on space, include this. not sure what to say to wrap up

\clearpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{refs}

\end{document}
\endinput
