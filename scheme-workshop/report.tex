\documentclass[dvipsnames,sigplan,screen,review,anonymous,acmthm,nonacm]{acmart}
% \documentclass[dvipsnames,sigplan,screen,acmthm]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{none}
% \setcopyright{acmcopyright}
% \copyrightyear{2018}
% \acmYear{2018}
% \acmDOI{10.1145/1122445.1122456}

%% TODO: does this matter?

% \citestyle{acmauthoryear}
\citestyle{acmnumeric}

\input{preamble}
\input{defs}

\begin{document}

\title{miniDusa: An Extensible Finite-Choice Logic Programming Language (Lightning Talk)}


%% TODO: alphabetical by last name or by first
%% name?? not sure which or it it matters

\author{Ari Prakash}
% \orcid{XXXX-XXXX-XXXX-XXXX}
\affiliation{%
  \institution{Northeastern University}
  \city{Boston}
  \state{MA}
  \country{USA}
}
\email{prakash.ar@northeastern.edu}
\authornote{Both authors contributed equally to this work}


\author{Zachary Eisbach}
% \orcid{0009-0005-3028-7211}
\affiliation{%
  \institution{Northeastern University}
  \city{Boston}
  \state{MA}
  \country{USA}
}
\email{eisbach.z@northeastern.edu}
\authornotemark[1]

% \authorsaddresses{}

\maketitle

\section{Introduction}

\Dusa{}~\cite{martens2025dusa} % maybe cite dusa.rocks impl too?
is a recently designed logic programming language featuring
\emph{mutually exclusive choice} as a primitive to enable
computation of solutions that satisfy constraints.

% TODO: sentence to bridge this gap?

We introduce \miniDusa{}, a \Dusa{}-inspired
% TODO: (nit) italics are awkward here. maybe omit DSL? 
\emph{hosted domain-specific language} (DSL) implemented using Racket and
the \syntaxspec{} metalanguage~\cite{ballantyne2024pearl}. % cite docs?
This architecture lets our implementation inherit tooling and features
from the host, like macro-extensibility, essentially ``for free''.


\section{miniDusa by Example}

A finite-choice logic program describes \emph{solutions}
(i.e. sets of consistent facts), which are obtained using a \emph{solver}.
To illuminate the semantics of \miniDusa{}, we walk through
a program whose solutions are the 3-colorings of some graph:

\begin{verbatim}
(logic
  (edge 'a 'b) (edge 'a 'c)  ; ... more ...
  ((edge X Y) :- (edge Y X))
  ((node X) :- (edge X _))
\end{verbatim}
A finite-choice logic program consists of \emph{facts} and \emph{rules}.
% like Datalog programs. 
The fact \texttt{(edge 'a 'b)} indicates that the \texttt{edge} predicate
holds of nodes \texttt{'a} and \texttt{'b}.
The premise of the rule \texttt{((edge X Y) :- (edge Y X))} will be
instantiated with this fact, concluding \texttt{(edge 'b 'a)}.
These facts and rules thus encode an undirected graph.

\begin{verbatim}
  (((color X) is {'r 'g 'b}) :- (node X))
\end{verbatim}
The conclusion of this rule is a \emph{functional proposition}
(indicated with \texttt{is}), as opposed to the \emph{relational} propositions above.
Each functional propositions has a unique associated value;
the value associated to (for instance) \texttt{color 'a} must
be a \emph{choice} among \texttt{'r}, \texttt{'g}, and \texttt{'b}.

Without any added constraints, the solutions will simply enumerate all
possible assignments of colors to nodes. We encode the additional constraint
that adjacent nodes have different color as follows to complete the program:

\begin{verbatim}
  ((ok) is {#t})
  (((ok) is {#f}) :- (edge X Y)
                     ((color X) is C)
                     ((color Y) is C)))
\end{verbatim}
The (functional) fact \texttt{((ok) is {\#t})} will always hold.
If adjacent nodes have the same color, then \texttt{((ok) is {\#f})}
will be concluded; this would violate the uniqueness requirement noted
above, causing any such solutions to be rejected.

We implement a relatively na√Øve solver based on the ``fact-set semantics''
described in~\cite{martens2025dusa}. Solving produces a stream of solutions,
each of which may be queried by users.

% TODO: maybe split two sections?
\section{Extensibility and Interoperability}
% KEEP IN MIND: this is the part that should be interesting for everyone!
% even if they don't care about logic programs. phrase with that in mind

% probably say a little bit about syntax-spec
% insert: the diagram
% do it in this order because it justifies macros?

% TODO: do we want to switch the order of these two subsections?

% the previous example is indicative of many miniDusa programs
% we want to abstract over common behavior, like the ok stuff
% dusa provides this as #forbid
% we conveniently implement it as a macro
% this is an instance of syntax-spec + DSL making impl easier :)

% users may also want a reusable graph definition, and ideally
% one that is less verbose. we again can do this with a macro!
% this is more powerful than before: we expect _users_ to write
% such macros, not just us as language implementers

% insert: the fully rewritten version.
% probably not any macro definitions, maybe just with ...

% reiterate that due to how syntax-spec is set-up, we get
% nice expansion into core miniDusa to do some checks before
% going any farther. i think that pattern is hard without syntax-spec
% META: see this is why i was unsure about the order of these subsections

% syntax spec not only lets us get macros, but also host language interop
% insert: the code with the contrived example
% then, talk about how we can use arbitrary racket functions,
% which is also nice for users: we inherit expressivity and can use libraries/etc

% \section{Conclusion}
% TODO: depending on space, include this. not sure what to say to wrap up

\clearpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{refs}

\end{document}
\endinput
