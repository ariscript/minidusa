\documentclass[dvipsnames,sigplan,screen,review,anonymous,acmthm,nonacm]{acmart}
% \documentclass[dvipsnames,sigplan,screen,acmthm]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{none}
% \setcopyright{acmcopyright}
% \copyrightyear{2018}
% \acmYear{2018}
% \acmDOI{10.1145/1122445.1122456}

%% TODO: does this matter?

% \citestyle{acmauthoryear}
\citestyle{acmnumeric}

\input{preamble}
\input{defs}

\begin{document}

\title{miniDusa: An Extensible Finite-Choice Logic Programming Language (Lightning Talk)}


%% TODO: alphabetical by last name or by first
%% name?? not sure which or it it matters

\author{Ari Prakash}
% \orcid{XXXX-XXXX-XXXX-XXXX}
\affiliation{%
  \institution{Northeastern University}
  \city{Boston}
  \state{MA}
  \country{USA}
}
\email{prakash.ar@northeastern.edu}
\authornote{Both authors contributed equally to this work}


\author{Zachary Eisbach}
% \orcid{0009-0005-3028-7211}
\affiliation{%
  \institution{Northeastern University}
  \city{Boston}
  \state{MA}
  \country{USA}
}
\email{eisbach.z@northeastern.edu}
\authornotemark[1]

% \authorsaddresses{}

\maketitle

\section{Introduction}

\Dusa{}~\cite{martens2025dusa} % maybe cite dusa.rocks impl too?
is a recently designed logic programming language featuring
\emph{mutually exclusive choice} as a primitive to enable
computation of solutions that satisfy constraints.

% TODO: sentence to bridge this gap?

We introduce \miniDusa{}, a \Dusa{}-inspired
% TODO: (nit) italics are awkward here. maybe omit DSL? 
\emph{hosted domain-specific language} (DSL) implemented using Racket and
the \syntaxspec{} metalanguage~\cite{ballantyne2024pearl}. % cite docs?
This architecture lets our implementation inherit tooling and features
from the host, like macro-extensibility, essentially ``for free''.


\section{miniDusa by Example}

A finite-choice logic program describes \emph{solutions}
(i.e. sets of consistent facts), which are obtained using a \emph{solver}.
To illuminate the semantics of \miniDusa{}, we walk through
a program whose solutions are the 3-colorings of some graph:

\begin{verbatim}
(logic
  (edge 'a 'b) (edge 'a 'c)  ; ... more ...
  ((edge X Y) :- (edge Y X))
  ((node X) :- (edge X _))
\end{verbatim}
A finite-choice logic program consists of \emph{facts} and \emph{rules}.
% like Datalog programs. 
The fact \texttt{(edge 'a 'b)} represents an edge from \texttt{'a} to \texttt{'b}.
The premise of the rule \texttt{((edge X Y) :- (edge Y X))} will be
instantiated with this fact to conclude \texttt{(edge 'b 'a)}.
These facts and rules thus encode an undirected graph.

\begin{verbatim}
  (((color X) is {'r 'g 'b}) :- (node X))
\end{verbatim}
% TODO: (nit) should this be indented?
The conclusion of this rule is a \emph{functional proposition}
(indicated with \texttt{is}), as opposed to the \emph{relational} propositions above.
Each functional proposition has a unique associated value---for instance,
the value associated to \texttt{color 'a} will be a
\emph{choice} among \texttt{'r}, \texttt{'g}, and \texttt{'b}.

Without any added constraints, the solutions will simply enumerate all
possible assignments of colors to nodes. We forbid solutions from
assigning the same color to adjacent nodes as follows to complete the \miniDusa{} program:

\begin{verbatim}
  (forbid (edge X Y)
          ((color X) is C)
          ((color Y) is C)))
\end{verbatim}
  % ((ok) is {#t})
  % (((ok) is {#f}) :- (edge X Y)
  %                    ((color X) is C)
  %                    ((color Y) is C)))
% The (functional) fact \texttt{((ok) is {\#t})} will always hold.
% If adjacent nodes have the same color, then \texttt{((ok) is {\#f})}
% will be concluded; this would violate the uniqueness requirement noted
% above, causing any such solutions to be rejected. 

We implement a relatively na√Øve solver based on the ``fact-set semantics''
described in~\cite{martens2025dusa}. Solving produces a stream of solutions,
each of which may be queried by users.

\section{Extensibility via Macros}
% KEEP IN MIND: this is the part that should be interesting for everyone!
% even if they don't care about logic programs. phrase with that in mind

The encoding of an undirected graph seen above is quite cumbersome. Users can
write \emph{macros} to abstract over encodings and express constructs in their
problem domain in a more natural way.

For instance, we can write an \texttt{undirected-graph} macro
which expands familiar adjacency-list notation into the facts
and rules from earlier:

% TODO: ...s here are a little weird...
\begin{verbatim}
(define-dsl-syntax undirected-graph logic-macro
  (syntax-parser ...))
(logic
  (undirected-graph edge node
    ('a ['b 'c]) #| ... more ... |# )
...
\end{verbatim}

In fact, we (conveniently) implement \texttt{forbid} and similar constraints
as macros too!
This is an instance of the project architecture simplifying the implementation effort.

The \texttt{define-dsl-syntax} form used above is provided by \syntaxspec{},
allowing \miniDusa{} macros to be carefully expanded into a slim core syntax.
This enables a static validation pass before further generation of Racket code.
% TODO: do we want a caption on the figure or just a sentence here? maybe space-dependent
% as shown in the figure below:

% TODO: not sure why this isn't properly centering...
\begin{figure}[h]
  \begin{center}
    \begin{tikzpicture}[
      box/.style={
        rectangle, draw, align=center,
        minimum width=2.2cm, minimum height=1.1cm,
        },
        label/.style={ midway, font=\small },
        every path/.style={-Stealth, thick}
      ]
      \node[box] (a) at (-2, 2) {\miniDusa{} +\\ extensions};
      \node[box] (b) at ( 2, 2) {Core\\ \miniDusa{}};
      \node[box] (c) at ( 2, 0) {Racket\\with runtime};
      \node[box, shape=ellipse] (d) at (-2, 0) {Solutions};
      
      % janky but it might work
      \draw[loop right] (b) to (b) node[font=\small, right, xshift=1.4cm, yshift=-0.7cm] {Check};
      
      \draw (a) -- (b) node[label, above] {Expand};
      \draw (b) -- (c) node[label, left] {Compile};
      \draw (c) -- (d) node[label, below] {Solve};
    \end{tikzpicture}
  \end{center}
  \caption{The \miniDusa{} pipeline}
\end{figure}

\section{Host-Language Interoperability}

% syntax spec not only lets us get macros, but also host language interop
% insert: the code with the contrived example
% then, talk about how we can use arbitrary racket functions,
% which is also nice for users: we inherit expressivity and can use libraries/etc

Using \texttt{syntax-spec}, we not only inherit Racket's hygenic macro system, we can
also have richer interoperability with Racket itself. miniDusa allows the user
to \emph{import} arbitrary Racket functions to be used as functional relations
within miniDusa. Since running arbitrary functions backwards is impossible, we
only allow this when all arguments are known, and we want to either bind or
verify the return value.

% \section{Conclusion}
% TODO: depending on space, include this. not sure what to say to wrap up

\clearpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{refs}

\end{document}
\endinput
